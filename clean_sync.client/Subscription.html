        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Subscription class / clean_sync.client Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="clean_sync.client" data-type="Subscription">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../clean_sync.client.html">clean_sync.client</a> &rsaquo; <a href="../clean_sync.client/Subscription.html">Subscription</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Subscription</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class Subscription {
 // constructor arguments:
 String collectionName;
 DataSet collection;
 Connection _connection;
 bool requestLock = false;
 bool updateLock = false;
 String _author;
 String toString() =&gt; 'Subscription(${_author}, ver: ${_version})';
 IdGenerator _idGenerator;
 Function _handleData = handleData;
 Function _handleDiff = handleDiff;
 /// Used for testing and debugging. If true, data (instead of diff) is
 /// requested periodically.
 bool _forceDataRequesting = false;
 Map args = {};
 /// Maps _id of a document to Future, that completes when server response
 /// to document's update is completed
 Map&lt;String, Future&gt; _modifiedItems = {};


 num _version;
 get version =&gt; _version;

 Completer _initialSync = new Completer();
 List&lt;StreamSubscription&gt; _subscriptions = [];
 StreamController _errorStreamController;
 Stream get errorStream {
   if (!_initialSync.isCompleted) throw new StateError("Initial sync not complete yet!");
   return _errorStreamController.stream;
 }

 /// Completes after first request to get data is answered and handled.
 Future get initialSync =&gt; _initialSync.future;

 Subscription.config(this.collectionName, this.collection, this._connection,
     this._author, this._idGenerator, this._handleData, this._handleDiff,
     this._forceDataRequesting, [this.args]);

 Subscription(this.collectionName, this._connection, this._author,
     this._idGenerator, [this.args]) {
   collection = new DataSet();
   collection.addIndex(['_id']);
   _errorStreamController = new StreamController.broadcast();
   start();
 }


 /**
  * Waits for initialSync of all provided subscriptions.
  */
 static Future wait(List&lt;Subscription&gt; subscriptions) {
   return Future.wait(
       subscriptions.map((subscription) =&gt; subscription.initialSync));
 }

 // TODO rename to something private-like
 void setupListeners() {
   _subscriptions.add(collection.onBeforeAdd.listen((data) {
     // if data["_id"] is null, it was added by this client and _id should be
     // assigned
     if(data["_id"] == null) {
       data["_id"] = _idGenerator.next();
     }
   }));

   markToken(id, result) {
     _modifiedItems[id] = result;
     result.then((nextVersion){
       if (_modifiedItems[id] == result) {
         _modifiedItems.remove(id);
       }
     });
   }

   var change = new ChangeSet();

   notify(){
     new Timer(new Duration(), (){
       change.addedItems.forEach((data) {
         Future result = _connection.send(() =&gt; new ClientRequest("sync", {
           "action" : "add",
           "collection" : collectionName,
           "data" : data,
           'args': args,
           "author" : _author
         })).then((result) {
           if (result is Map)
             if (result['error'] != null)
               _errorStreamController.add(result['error']);
         });
         markToken(data['_id'], result);
       });

       change.strictlyChanged.forEach((DataMap data, ChangeSet changeSet) {
         Future result = _connection.send(() =&gt; new ClientRequest("sync", {
           "action" : "change",
           "collection" : collectionName,
           'args': args,
           "_id": data["_id"],
           "change" : data,
           "author" : _author
         })).then((result) {
           if (result is Map)
             if (result['error'] != null)
               _errorStreamController.add(result['error']);
         });
         // TODO: check if server really accepted the change
         markToken(data['_id'], result);
       });

       change.removedItems.forEach((data) {
         Future result = _connection.send(() =&gt; new ClientRequest("sync", {
           "action" : "remove",
           "collection" : collectionName,
           'args': args,
           "_id" : data["_id"],
           "author" : _author
         })).then((result) {
           if (result is Map)
             if (result['error'] != null)
               _errorStreamController.add(result['error']);
         });
         markToken(data['_id'], result);
       });
       change = new ChangeSet();
     });
   }

   _subscriptions.add(collection.onChangeSync.listen((event) {
     if (!this.updateLock) {
       var newChange = event['change'];
       assert(newChange is ChangeSet);
       change.mergeIn(newChange);
       notify();
     }
   }));
 }

 _createDataRequest() =&gt; new ClientRequest("sync", {
   "action" : "get_data",
   "collection" : collectionName,
   'args': args
 });

 _createDiffRequest() {
   if (requestLock) {
     return null;
   } else {
     requestLock = true;
     return new ClientRequest("sync", {
     "action" : "get_diff",
     "collection" : collectionName,
     'args': args,
     "version" : _version
     });
   }
 }

 // TODO rename to something private-like
 void setupDataRequesting() {
   // request initial data
   _connection.send(_createDataRequest).then((response) {
     if (response['error'] != null) {
       if (!_initialSync.isCompleted) _initialSync.completeError(new DatabaseAccessError(response['error']));
       else _errorStreamController.add(new DatabaseAccessError(response['error']));
       return;
     }
     _version = response['version'];
     _handleData(response['data'], this, _author);

     logger.info("Got initial data, synced to version ${_version}");

     // TODO remove the check? (restart/dispose should to sth about initialSynd)
     if (!_initialSync.isCompleted) _initialSync.complete();

     var subscription = _connection
       .sendPeriodically(_forceDataRequesting ?
           _createDataRequest : _createDiffRequest)
       .listen((response) {
         requestLock = false;
         // id data and version was sent, diff is set to null
         if(response['diff'] == null) {
           _version = response['version'];
           _handleData(response['data'], this, _author);
         } else {
           if(!response['diff'].isEmpty) {
             _version = max(_version, _handleDiff(response['diff'], this, _author));
             } else {
               _version = response['version'];
             }
           }
       }, onError: (e){if (e is! CancelError)throw e;});
     _subscriptions.add(subscription);
   });
 }

 void start() {
   setupListeners();
   setupDataRequesting();
 }

 Future dispose() {
   return Future.forEach(_subscriptions, (sub) =&gt; sub.cancel());
 }

 Future close() {
   return dispose()
     .then((_) =&gt;
       Future.wait(_modifiedItems.values))
     .then((_) =&gt;
        new Future.delayed(new Duration(milliseconds: 100), (){
         collection.dispose();
   }));
 }

 Future restart([Map args]) {
   this.args = args;
   return dispose().then((_) {
     start();
   });
 }

 Stream onClose() {

 }
}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="wait">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>wait</strong>(<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../clean_sync.client/Subscription.html">Subscription</a>&gt; subscriptions) <a class="anchor-link" href="#wait"
              title="Permalink to Subscription.wait">#</a></h4>
<div class="doc">
<p>Waits for initialSync of all provided subscriptions.</p>
<pre class="source">
static Future wait(List&lt;Subscription&gt; subscriptions) {
 return Future.wait(
     subscriptions.map((subscription) =&gt; subscription.initialSync));
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Subscription</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> collectionName, <a href="../clean_ajax.client/Connection.html">Connection</a> _connection, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> _author, <a href="../clean_sync.client/IdGenerator.html">IdGenerator</a> _idGenerator, [<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> args]) <a class="anchor-link" href="#"
              title="Permalink to Subscription.Subscription">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
Subscription(this.collectionName, this._connection, this._author,
   this._idGenerator, [this.args]) {
 collection = new DataSet();
 collection.addIndex(['_id']);
 _errorStreamController = new StreamController.broadcast();
 start();
}
</pre>
</div>
</div>
<div class="method"><h4 id="config">
<button class="show-code">Code</button>
new <strong>Subscription.config</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> collectionName, <a href="../clean_data/DataSet.html">DataSet</a> collection, <a href="../clean_ajax.client/Connection.html">Connection</a> _connection, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> _author, <a href="../clean_sync.client/IdGenerator.html">IdGenerator</a> _idGenerator, <a href="http://api.dartlang.org/dart_core/Function.html" ref="external">Function</a> _handleData, <a href="http://api.dartlang.org/dart_core/Function.html" ref="external">Function</a> _handleDiff, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> _forceDataRequesting, [<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> args]) <a class="anchor-link" href="#config"
              title="Permalink to Subscription.Subscription.config">#</a></h4>
<div class="doc">
<pre class="source">
Subscription.config(this.collectionName, this.collection, this._connection,
   this._author, this._idGenerator, this._handleData, this._handleDiff,
   this._forceDataRequesting, [this.args]);
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="args">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a>         <strong>args</strong> <a class="anchor-link"
            href="#args"
            title="Permalink to Subscription.args">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Map args = {}
</pre>
</div>
</div>
<div class="field"><h4 id="collection">
<button class="show-code">Code</button>
<a href="../clean_data/DataSet.html">DataSet</a>         <strong>collection</strong> <a class="anchor-link"
            href="#collection"
            title="Permalink to Subscription.collection">#</a>
        </h4>
        <div class="doc">
<pre class="source">
DataSet collection
</pre>
</div>
</div>
<div class="field"><h4 id="collectionName">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>collectionName</strong> <a class="anchor-link"
            href="#collectionName"
            title="Permalink to Subscription.collectionName">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String collectionName
</pre>
</div>
</div>
<div class="field"><h4 id="errorStream">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>         <strong>errorStream</strong> <a class="anchor-link"
            href="#errorStream"
            title="Permalink to Subscription.errorStream">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream get errorStream {
 if (!_initialSync.isCompleted) throw new StateError("Initial sync not complete yet!");
 return _errorStreamController.stream;
}
</pre>
</div>
</div>
<div class="field"><h4 id="initialSync">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>         <strong>initialSync</strong> <a class="anchor-link"
            href="#initialSync"
            title="Permalink to Subscription.initialSync">#</a>
        </h4>
        <div class="doc">
<p>Completes after first request to get data is answered and handled.</p>
<pre class="source">
Future get initialSync =&gt; _initialSync.future;
</pre>
</div>
</div>
<div class="field"><h4 id="requestLock">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>requestLock</strong> <a class="anchor-link"
            href="#requestLock"
            title="Permalink to Subscription.requestLock">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool requestLock = false
</pre>
</div>
</div>
<div class="field"><h4 id="updateLock">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>updateLock</strong> <a class="anchor-link"
            href="#updateLock"
            title="Permalink to Subscription.updateLock">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool updateLock = false
</pre>
</div>
</div>
<div class="field"><h4 id="version">
<button class="show-code">Code</button>
final         <strong>version</strong> <a class="anchor-link"
            href="#version"
            title="Permalink to Subscription.version">#</a>
        </h4>
        <div class="doc">
<pre class="source">
get version =&gt; _version;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="close">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>close</strong>() <a class="anchor-link" href="#close"
              title="Permalink to Subscription.close">#</a></h4>
<div class="doc">
<pre class="source">
Future close() {
 return dispose()
   .then((_) =&gt;
     Future.wait(_modifiedItems.values))
   .then((_) =&gt;
      new Future.delayed(new Duration(milliseconds: 100), (){
       collection.dispose();
 }));
}
</pre>
</div>
</div>
<div class="method"><h4 id="dispose">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>dispose</strong>() <a class="anchor-link" href="#dispose"
              title="Permalink to Subscription.dispose">#</a></h4>
<div class="doc">
<pre class="source">
Future dispose() {
 return Future.forEach(_subscriptions, (sub) =&gt; sub.cancel());
}
</pre>
</div>
</div>
<div class="method"><h4 id="onClose">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> <strong>onClose</strong>() <a class="anchor-link" href="#onClose"
              title="Permalink to Subscription.onClose">#</a></h4>
<div class="doc">
<pre class="source">
Stream onClose() {

}
</pre>
</div>
</div>
<div class="method"><h4 id="restart">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>restart</strong>([<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> args]) <a class="anchor-link" href="#restart"
              title="Permalink to Subscription.restart">#</a></h4>
<div class="doc">
<pre class="source">
Future restart([Map args]) {
 this.args = args;
 return dispose().then((_) {
   start();
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="setupDataRequesting">
<button class="show-code">Code</button>
void <strong>setupDataRequesting</strong>() <a class="anchor-link" href="#setupDataRequesting"
              title="Permalink to Subscription.setupDataRequesting">#</a></h4>
<div class="doc">
<pre class="source">
void setupDataRequesting() {
 // request initial data
 _connection.send(_createDataRequest).then((response) {
   if (response['error'] != null) {
     if (!_initialSync.isCompleted) _initialSync.completeError(new DatabaseAccessError(response['error']));
     else _errorStreamController.add(new DatabaseAccessError(response['error']));
     return;
   }
   _version = response['version'];
   _handleData(response['data'], this, _author);

   logger.info("Got initial data, synced to version ${_version}");

   // TODO remove the check? (restart/dispose should to sth about initialSynd)
   if (!_initialSync.isCompleted) _initialSync.complete();

   var subscription = _connection
     .sendPeriodically(_forceDataRequesting ?
         _createDataRequest : _createDiffRequest)
     .listen((response) {
       requestLock = false;
       // id data and version was sent, diff is set to null
       if(response['diff'] == null) {
         _version = response['version'];
         _handleData(response['data'], this, _author);
       } else {
         if(!response['diff'].isEmpty) {
           _version = max(_version, _handleDiff(response['diff'], this, _author));
           } else {
             _version = response['version'];
           }
         }
     }, onError: (e){if (e is! CancelError)throw e;});
   _subscriptions.add(subscription);
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="setupListeners">
<button class="show-code">Code</button>
void <strong>setupListeners</strong>() <a class="anchor-link" href="#setupListeners"
              title="Permalink to Subscription.setupListeners">#</a></h4>
<div class="doc">
<pre class="source">
void setupListeners() {
 _subscriptions.add(collection.onBeforeAdd.listen((data) {
   // if data["_id"] is null, it was added by this client and _id should be
   // assigned
   if(data["_id"] == null) {
     data["_id"] = _idGenerator.next();
   }
 }));

 markToken(id, result) {
   _modifiedItems[id] = result;
   result.then((nextVersion){
     if (_modifiedItems[id] == result) {
       _modifiedItems.remove(id);
     }
   });
 }

 var change = new ChangeSet();

 notify(){
   new Timer(new Duration(), (){
     change.addedItems.forEach((data) {
       Future result = _connection.send(() =&gt; new ClientRequest("sync", {
         "action" : "add",
         "collection" : collectionName,
         "data" : data,
         'args': args,
         "author" : _author
       })).then((result) {
         if (result is Map)
           if (result['error'] != null)
             _errorStreamController.add(result['error']);
       });
       markToken(data['_id'], result);
     });

     change.strictlyChanged.forEach((DataMap data, ChangeSet changeSet) {
       Future result = _connection.send(() =&gt; new ClientRequest("sync", {
         "action" : "change",
         "collection" : collectionName,
         'args': args,
         "_id": data["_id"],
         "change" : data,
         "author" : _author
       })).then((result) {
         if (result is Map)
           if (result['error'] != null)
             _errorStreamController.add(result['error']);
       });
       // TODO: check if server really accepted the change
       markToken(data['_id'], result);
     });

     change.removedItems.forEach((data) {
       Future result = _connection.send(() =&gt; new ClientRequest("sync", {
         "action" : "remove",
         "collection" : collectionName,
         'args': args,
         "_id" : data["_id"],
         "author" : _author
       })).then((result) {
         if (result is Map)
           if (result['error'] != null)
             _errorStreamController.add(result['error']);
       });
       markToken(data['_id'], result);
     });
     change = new ChangeSet();
   });
 }

 _subscriptions.add(collection.onChangeSync.listen((event) {
   if (!this.updateLock) {
     var newChange = event['change'];
     assert(newChange is ChangeSet);
     change.mergeIn(newChange);
     notify();
   }
 }));
}
</pre>
</div>
</div>
<div class="method"><h4 id="start">
<button class="show-code">Code</button>
void <strong>start</strong>() <a class="anchor-link" href="#start"
              title="Permalink to Subscription.start">#</a></h4>
<div class="doc">
<pre class="source">
void start() {
 setupListeners();
 setupDataRequesting();
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to Subscription.toString">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns a string representation of this object.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
String toString() =&gt; 'Subscription(${_author}, ver: ${_version})';
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
