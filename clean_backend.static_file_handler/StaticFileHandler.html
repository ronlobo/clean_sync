        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>StaticFileHandler class / clean_backend.static_file_handler Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="clean_backend.static_file_handler" data-type="StaticFileHandler">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../clean_backend.static_file_handler.html">clean_backend.static_file_handler</a> &rsaquo; <a href="../clean_backend.static_file_handler/StaticFileHandler.html">StaticFileHandler</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>StaticFileHandler</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class StaticFileHandler {
 Builder _root;
 String get documentRoot =&gt; _root.root;

 /**
  * Default constructor.
  */
 StaticFileHandler(String documentRoot) {
   _root = new Builder(root: absolute(normalize(documentRoot)));

   var dir = new Directory(_root.root);
   if (!dir.existsSync()) {
     throw new ArgumentError("Root path '$documentRoot' does not exist or is not a directory");
   }
 }

 /**
  * Add the MIME types [types] to the list of supported MIME types
  */
 void addMIMETypes(Map&lt;String, String&gt; types){
   _extToContentType.addAll(types);
 }

 /**
  * Serve the file [file] to the [request]. The content of the file will be
  * streamed to the response. If a supported [:Range:] header is received, only
  * a smaller part of the [file] will be streamed.
  */
 void _serveFile(File file, HttpRequest request) {
   HttpResponse response = request.response;

   // Callback used if file operations fails.
   void fileError(e) {
     response.statusCode = HttpStatus.NOT_FOUND;
     response.close();
   }

   //TODO consider:
   //var file = new File(Platform.script.toFilePath());
   //Future&lt;String&gt; finishedReading = file.readAsString(encoding: Encoding.ASCII
   void pipeToResponse(Stream&lt;List&lt;int&gt;&gt; fileContent, HttpResponse response) {
     response.addStream(fileContent).then((_) =&gt; response.close()).catchError(
         //TODO
       (error) =&gt; throw new StateError("Streaming file gone wrong.")
     );
   }

   void _sendRange(File file, HttpResponse response, String range, length) {
     // TODO We only support one range, where the standard support several.
     Match matches = new RegExp(r"^bytes=(\d*)\-(\d*)$").firstMatch(range);

     // If the range header have the right format, handle it.
     if (matches != null) {
       // Serve sub-range.
       int start;
       int end;
       if (matches[1].isEmpty) {
         start = matches[2].isEmpty ? length : length - int.parse(matches[2]);
         end = length;
       } else {
         start = int.parse(matches[1]);
         end = matches[2].isEmpty ? length : int.parse(matches[2]) + 1;
       }

       // Override Content-Length with the actual bytes sent.
       response.headers.set(HttpHeaders.CONTENT_LENGTH, end - start);

       // Set 'Partial Content' status code.
       response.statusCode = HttpStatus.PARTIAL_CONTENT;
       response.headers.set(HttpHeaders.CONTENT_RANGE, "bytes $start-${end - 1}/$length");

       // Pipe the 'range' of the file.
       pipeToResponse(file.openRead(start, end), response);
     }
   }

   file.lastModified().then((lastModified) {
     // If If-Modified-Since is present and file haven't changed, return 304.
     if (request.headers.ifModifiedSince != null &amp;&amp;
         !lastModified.isAfter(request.headers.ifModifiedSince)) {
       response.statusCode = HttpStatus.NOT_MODIFIED;
       response.close();
       return;
     }

     file.length().then((length) {
       // Always set Accept-Ranges and Last-Modified headers.
       response.headers.set(HttpHeaders.ACCEPT_RANGES, "bytes");
       response.headers.set(HttpHeaders.LAST_MODIFIED, lastModified);

       String ext = extension(file.path);
       if (_extToContentType.containsKey(ext.toLowerCase())) {
         response.headers.contentType = ContentType.parse(_extToContentType[ext.toLowerCase()]);
       }

       if (request.method == 'HEAD') {
         response.close();
         return;
       }

       // If the Range header was received, handle it.
       String range = request.headers.value("range");
       if (range != null) {
         _sendRange(file, response, range, length);
         return;
       }

       /*
        * Send content length if using HTTP/1.0
        * When using HTTP/1.1 chunked transfer encoding is used
        */
       if (request.protocolVersion == "1.0") {
         response.headers.set(HttpHeaders.CONTENT_LENGTH, length);
       }

       // Fall back to sending the entire content.
       pipeToResponse(file.openRead(), response);
     }, onError: fileError);
   }, onError: fileError);
 }

 /**
  * Seeks for file at documentRoot/relativePath and depending on [request]
  * parameters it fills [request.response].
  */
 void handleRequest(HttpRequest request, String relativePath) {
   request.response.done.catchError(
       //TODO
     (error) =&gt; throw new StateError("Error creating response")
   );

   //TODO check format, consider using Builder
   String path = documentRoot + "/" + relativePath;

   FileSystemEntity.type(path)
   .then((type) {
     switch (type) {
       case FileSystemEntityType.FILE:
         // If file, serve as such.
         _serveFile(new File(path), request);
         break;

       case FileSystemEntityType.DIRECTORY:
         // File not found, fall back to 404.
         request.response.statusCode = HttpStatus.NOT_FOUND;
         request.response.close();
         break;

       default:
         // File not found, fall back to 404.
         request.response.statusCode = HttpStatus.NOT_FOUND;
         request.response.close();
         break;
     }
   });
 }

 //TODO extend list, consider moving into separate file
 //Extensions are in format as returned by Builder.extension()
 final _extToContentType = {
   ".bz"      : "application/x-bzip",
   ".bz2"     : "application/x-bzip2",
   ".dart"    : "application/dart",
   ".exe"     : "application/octet-stream",
   ".gif"     : "image/gif",
   ".gz"      : "application/x-gzip",
   ".html"    : "text/html; charset=utf-8",  // Assumes UTF-8 files.
   ".jpg"     : "image/jpeg",
   ".js"      : "application/javascript",
   ".json"    : "application/json",
   ".mp3"     : "audio/mpeg",
   ".mp4"     : "video/mp4",
   ".pdf"     : "application/pdf",
   ".png"     : "image/png",
   ".tar.gz"  : "application/x-tar",
   ".tgz"     : "application/x-tar",
   ".txt"     : "text/plain; charset=utf-8",  // Assumes UTF-8 files.
   ".webp"    : "image/webp",
   ".webm"    : "video/webm",
   ".zip"     : "application/zip",
   ".css"     : "text/css",
 };
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>StaticFileHandler</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> documentRoot) <a class="anchor-link" href="#"
              title="Permalink to StaticFileHandler.StaticFileHandler">#</a></h4>
<div class="doc">
<p>Default constructor.</p>
<pre class="source">
StaticFileHandler(String documentRoot) {
 _root = new Builder(root: absolute(normalize(documentRoot)));

 var dir = new Directory(_root.root);
 if (!dir.existsSync()) {
   throw new ArgumentError("Root path '$documentRoot' does not exist or is not a directory");
 }
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="documentRoot">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>documentRoot</strong> <a class="anchor-link"
            href="#documentRoot"
            title="Permalink to StaticFileHandler.documentRoot">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String get documentRoot =&gt; _root.root;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="addMIMETypes">
<button class="show-code">Code</button>
void <strong>addMIMETypes</strong>(<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt; types) <a class="anchor-link" href="#addMIMETypes"
              title="Permalink to StaticFileHandler.addMIMETypes">#</a></h4>
<div class="doc">
<p>Add the MIME types 
<span class="param">types</span> to the list of supported MIME types</p>
<pre class="source">
void addMIMETypes(Map&lt;String, String&gt; types){
 _extToContentType.addAll(types);
}
</pre>
</div>
</div>
<div class="method"><h4 id="handleRequest">
<button class="show-code">Code</button>
void <strong>handleRequest</strong>(<a href="http://api.dartlang.org/dart_io/HttpRequest.html" ref="external">HttpRequest</a> request, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> relativePath) <a class="anchor-link" href="#handleRequest"
              title="Permalink to StaticFileHandler.handleRequest">#</a></h4>
<div class="doc">
<p>Seeks for file at documentRoot/relativePath and depending on 
<span class="param">request</span>
parameters it fills <code>request.response</code>.</p>
<pre class="source">
void handleRequest(HttpRequest request, String relativePath) {
 request.response.done.catchError(
     //TODO
   (error) =&gt; throw new StateError("Error creating response")
 );

 //TODO check format, consider using Builder
 String path = documentRoot + "/" + relativePath;

 FileSystemEntity.type(path)
 .then((type) {
   switch (type) {
     case FileSystemEntityType.FILE:
       // If file, serve as such.
       _serveFile(new File(path), request);
       break;

     case FileSystemEntityType.DIRECTORY:
       // File not found, fall back to 404.
       request.response.statusCode = HttpStatus.NOT_FOUND;
       request.response.close();
       break;

     default:
       // File not found, fall back to 404.
       request.response.statusCode = HttpStatus.NOT_FOUND;
       request.response.close();
       break;
   }
 });
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
