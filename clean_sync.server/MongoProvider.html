        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>MongoProvider class / clean_sync.server Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="clean_sync.server" data-type="MongoProvider">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../clean_sync.server.html">clean_sync.server</a> &rsaquo; <a href="../clean_sync.server/MongoProvider.html">MongoProvider</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>MongoProvider</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class MongoProvider implements DataProvider {
 final DbCollection collection, _collectionHistory, _lock;
 List&lt;Map&gt; _selectorList = [];
 Map _sortParams = {};
 num _limit = NOLIMIT;
 num _skip = NOSKIP;

 Future&lt;int&gt; get _maxVersion =&gt;
     _collectionHistory.find(where.sortBy('version', descending : true)
         .limit(1)).toList()
     .then((data) =&gt; data.isEmpty? 0: data.first['version']);

 Map get _rawSelector =&gt; {QUERY: _selectorList.isEmpty ?
     {} : {AND: _selectorList}, ORDERBY: _sortParams};

 MongoProvider(this.collection, this._collectionHistory, this._lock);

 void _copySelection(MongoProvider mp) {
   this._sortParams = new Map.from(mp._sortParams);
   this._selectorList = new List.from(mp._selectorList);
   this._limit = mp._limit;
   this._skip = mp._skip;
 }

 Future deleteHistory(num version) {
   return _collectionHistory.remove({'version': {LT: version}});
 }

 MongoProvider find(Map params) {
   var mp = new MongoProvider(collection, _collectionHistory, _lock);
   mp._copySelection(this);
   mp._selectorList.add(params);
   return mp;
 }

 MongoProvider sort(Map params) {
   var mp = new MongoProvider(collection, _collectionHistory, _lock);
   mp._copySelection(this);
   mp._sortParams.addAll(params);
   return mp;
 }

 MongoProvider limit(num value) {
   var mp = new MongoProvider(collection, _collectionHistory, _lock);
   mp._copySelection(this);
   mp._limit = value;
   return mp;
 }

 MongoProvider skip(num value) {
   var mp = new MongoProvider(collection, _collectionHistory, _lock);
   mp._copySelection(this);
   mp._skip = value;
   return mp;
 }

 /**
  * Returns data and version of this data 7.
  */
 Future&lt;Map&gt; data({projection: null, stripVersion: true}) {
   return collection.find(where.raw(_rawSelector).limit(_limit).skip(_skip)).toList().then((data) {
     //return _maxVersion.then((version) =&gt; {'data': data, 'version': version});
     var version = data.length == 0 ? 0 : data.map((item) =&gt; item['__clean_version']).reduce(max);
     if(stripVersion) _stripCleanVersion(data);
     if (projection != null){
       data.forEach((e) =&gt; projection(e));
     }
     return {'data': data, 'version': version};
   });
 }

 Future add(Map data, String author) {
   num nextVersion;
   return _get_locks().then((_) =&gt; _maxVersion).then((version) {
       nextVersion = version + 1;
       data[VERSION_FIELD_NAME] = nextVersion;
       return collection.insert(data);
     }).then((_) =&gt;
       _collectionHistory.insert({
         "before" : {},
         "after" : data,
         "action" : "add",
         "author" : author,
         "version" : nextVersion
       }),
     onError: (e) {
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       return _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
 }

 Future addAll(List&lt;Map&gt; data, String author) {
   num nextVersion;
   return _get_locks().then((_) =&gt; _maxVersion).then((version) {
       nextVersion = version + 1;
       data.forEach((elem) =&gt; elem[VERSION_FIELD_NAME] = nextVersion++);
       return collection.insertAll(data);
     }).then((_) =&gt;
       _collectionHistory.insertAll(data.map((elem) =&gt;
           {
             "before" : {},
             "after" : elem,
             "action" : "add",
             "author" : author,
             "version" : elem[VERSION_FIELD_NAME]
           }).toList(growable: false)),
     onError: (e) {
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       return _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
 }

 Future deprecatedChange(String _id, Map change, String author) {
   num nextVersion;
   Map newRecord;
   return _get_locks().then((_) =&gt; collection.findOne({"_id" : _id}))
     .then((Map record) {
       if(record == null) {
         throw new MongoException(null,
             'Change was not applied, document with id $_id does not exist.');
       } else if (change.containsKey('_id') &amp;&amp; change['_id'] != _id) {
         throw new MongoException(null,
             'New document id ${change['_id']} should be same as old one $_id.');
       } else {
         return _maxVersion.then((version) {
           nextVersion = version + 1;
           newRecord = new Map.from(record);
           newRecord.addAll(change);
           newRecord[VERSION_FIELD_NAME] = nextVersion;
           return collection.save(newRecord);
         }).then((_) =&gt;
           _collectionHistory.insert({
             "before" : record,
             "after" : newRecord,
             "action" : "change",
             "author" : author,
             "version" : nextVersion
           }));
       }
     },
     onError: (e) {
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       return _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
 }

 //TODO: change means new data, rename it
 Future change(String _id, Map change, String author) {
   num nextVersion;
   Map newRecord;
   return _get_locks().then((_) =&gt; collection.findOne({"_id" : _id}))
     .then((Map record) {
       if(record == null) {
         return true;
//          throw new MongoException(null,
//              'Change was not applied, document with id $_id does not exist.');
       } else if (change.containsKey('_id') &amp;&amp; change['_id'] != _id) {
         throw new MongoException(null,
             'New document id ${change['_id']} should be same as old one $_id.');
       } else {
         return _maxVersion.then((version) {
           nextVersion = version + 1;
           newRecord = change;
           newRecord[VERSION_FIELD_NAME] = nextVersion;
           return collection.save(newRecord);
         }).then((_) =&gt;
           _collectionHistory.insert({
             "before" : record,
             "after" : newRecord,
             "action" : "change",
             "author" : author,
             "version" : nextVersion
           }));
       }
     },
     onError: (e) {
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       return _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
 }

 Future update(selector,Map document, String author, {bool upsert: false, bool multiUpdate: false, WriteConcern writeConcern}) {
   num nextVersion;
   List oldData;
   return _get_locks().then((_) =&gt; _maxVersion).then((version) {
       nextVersion = version + 1;
       num versionUpdate = nextVersion;
       var prepare;
       if(document.keys.any((K) =&gt; K.startsWith('\$'))) {
         prepare = (doc) {
           doc[SET][VERSION_FIELD_NAME] =  versionUpdate++;
           return doc;
         };
         if(!document.containsKey(SET))
           document[SET] = {};
       }
       else {
         prepare = (doc) {
           doc[VERSION_FIELD_NAME] =  versionUpdate++;
           return doc;
         };
       }

       var col = collection.find(selector);
       return col.toList().then((data) {
         oldData = data;
         return Future.forEach(data,
             (item) =&gt; collection.update({'_id': item['_id']},
                 prepare(document), upsert: upsert, multiUpdate: multiUpdate,
                 writeConcern: writeConcern));
       });
     }).then((_) {
       return Future.forEach(oldData,
         (oldItem) {
           return collection.find({'_id': oldItem['_id']}).toList().then((newItem) =&gt;
           _collectionHistory.insert({
             "before" : oldItem,
             "after" : newItem.single,
             "action" : "change",
             "author" : author,
             "version" : nextVersion++
           }));
         });
       }).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion)
       .catchError( (e) {
         // Errors thrown by MongoDatabase are Map objects with fields err, code,
         // ...
         return _release_locks().then((_) {
           throw new MongoException(e);
         });
       });
 }

 Future remove(String _id, String author) {
   num nextVersion;
   return _get_locks().then((_) =&gt; _maxVersion).then((version) {
       nextVersion = version + 1;
       return collection.findOne({'_id': _id});
     }).then((record) {
       if (record == null) {
         return true;
       } else {
         return collection.remove({'_id': _id}).then((_) =&gt;
           _collectionHistory.insert({
             "before" : record,
             "after" : {},
             "action" : "remove",
             "author" : author,
             "version" : nextVersion
         }));
       }
     },
     onError: (e) {
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       return _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
 }

 Future removeAll(query, String author) {
   num nextVersion;
   return _get_locks().then((_) =&gt; _maxVersion).then((version) {
       nextVersion = version + 1;
       return collection.find(query).toList();
     }).then((data) {
       return collection.remove(query).then((_) =&gt;
         _collectionHistory.insertAll(data.map((elem) =&gt; {
           "before" : elem,
           "after" : {},
           "action" : "remove",
           "author" : author,
           "version" : nextVersion++
       }).toList(growable: false)));
     },
     onError: (e) {
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       return _release_locks().then((_) {
         throw new MongoException(e);
       });
     }
     ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
 }

 Future&lt;Map&gt; diffFromVersion(num version, {projection: null}) {
   try{
     return _diffFromVersion(version, projection: projection).then((d) {
       return d;
     });
   } on DiffNotPossibleException catch(e) {
     return data(projection: projection).then((d) {
       d['diff'] = null;
       return d;
     });
   }
 }

 List pretify(List diff){
   Set seen = new Set();
   var res = [];
   for (Map change in diff.reversed) {
     var id = change['_id']+change['action'];
     assert(id is String);
     if (!seen.contains(id)) {
       res.add(change);
     }
     seen.add(id);
   }
   return new List.from(res.reversed);
 }

 Future&lt;Map&gt; _diffFromVersion(num version, {projection:null}) {
   // if (some case not covered so far) {
   // throw new DiffNotPossibleException('diff not possible');
   // selects records that fulfilled _selector before change
   Map beforeSelector = {QUERY : {}, ORDERBY : {"version" : 1}};
   // selects records that fulfill _selector after change
   Map afterSelector = {QUERY : {}, ORDERBY : {"version" : 1}};
   // selects records that fulfill _selector before or after change
   Map beforeOrAfterSelector = {QUERY : {}, ORDERBY : {"version" : 1}};

   // {before: {GT: {}}} to handle selectors like {before.age: null}
   List&lt;Map&gt; _beforeSelector = [{"version" : {GT : version}}, {"before" : {GT: {}}}];
   List&lt;Map&gt; _afterSelector = [{"version" : {GT : version}}, {"after" : {GT: {}}}];
   _selectorList.forEach((item) {
     Map itemB = {};
     Map itemA = {};
     item.forEach((key, val) {
       itemB["before.${key}"] = val;
       itemA["after.${key}"] = val;
     });
     _beforeSelector.add(itemB);
     _afterSelector.add(itemA);
   });
   beforeSelector[QUERY][AND] = _beforeSelector;
   afterSelector[QUERY][AND] = _afterSelector;
   beforeOrAfterSelector[QUERY][OR] = [{AND: _beforeSelector},
                                       {AND: _afterSelector}];

   Set before, after;
   List beforeOrAfter, diff;

    return _maxVersion.then((maxVersion) {
       return _collectionHistory.find(beforeOrAfterSelector).toList()
       .then((result) {
         beforeOrAfter = result;
         return Future.wait([
           _collectionHistory.find(beforeSelector).toList(),
           _collectionHistory.find(afterSelector).toList()]);})
       .then((results) {
           before = new Set.from(results[0].map((d) =&gt; d['_id']));
           after = new Set.from(results[1].map((d) =&gt; d['_id']));
           diff = [];

           beforeOrAfter.forEach((record) {
             assert(record['version']&gt;version);

             _stripCleanVersion(record['before']);
             _stripCleanVersion(record['after']);

             if(before.contains(record['_id']) &amp;&amp; after.contains(record['_id']))
             {
               // record was changed
               diff.add({
                 "action" : "change",
                 "_id" : record["before"]["_id"],
                 "before" : record["before"],
                 "data" : record["after"],
                 "version" : record["version"],
                 "author" : record["author"],
               });
             } else if(before.contains(record['_id'])) {
               // record was removed
               diff.add({
                 "action" : "remove",
                 "_id" : record["before"]["_id"],
                 "data" : record["before"],
                 "version" : record["version"],
                 "author" : record["author"],
               });
             } else {
               // record was added
               diff.add({
                 "action" : "add",
                 "_id" : record["after"]["_id"],
                 "data" : record["after"],
                 "version" : record["version"],
                 "author" : record["author"],
               });
             }
           });

           if (_limit &gt; NOLIMIT || _skip &gt; NOSKIP) {
             throw new Exception('not correctly implemented');
             return _limitedDiffFromVersion(diff);
           }

           if (projection!=null) {
             for (Map elem in diff) {
               if(elem.containsKey('data')){
                 projection(elem['data']);
               }
             }
           }

           if (diff.isEmpty) {
             return {'diff' : [], 'version' : maxVersion};
           } else {
             return {'diff' : pretify(diff)};
           }
       });
   });
 }

 num _defaultCompare(a, b) {
   return Comparable.compare(a,b); //a.compareTo(b);
 }

 _getCompareFunction(bool reverse) {
   if (reverse) {
     return (a, b) =&gt; -1 * _defaultCompare(a, b);
   }

   return _defaultCompare;
 }

 _getComparator(Map sortParams) {
   List&lt;Map&gt; fields = [];

   sortParams.forEach((field, order) {
     fields.add({"name" : field, "comparator" : _getCompareFunction(order == -1)});
   });

   return (Map item1, Map item2) {
     String name;
     num result = 0;

     for (Map field in fields) {
       name = field["name"];

       result = field["comparator"](item1[name], item2[name]);

       if (result != 0) {
         break;
       }
     }

     return result;
   };
 }

 void _insertIntoSorted(List&lt;Map&gt; data, Map record, Map sortParams) {
   data.add(record);
   data.sort(_getComparator(sortParams));
 }

 Future&lt;List&lt;Map&gt;&gt; _limitedDiffFromVersion(List&lt;Map&gt; diff) {
   return collection.find(where.raw(_rawSelector).limit(_skip + _limit + diff.length)).toList().then((data) {
     return collection.find(where.raw(_rawSelector).limit(_limit).skip(_skip)).toList().then((currentData) {
       List&lt;Map&gt; reversedDiff = diff.reversed.toList();
       List&lt;Map&gt; clientData = new List.from(data);
       List&lt;Map&gt; clientDiff = [];
       num maxVersion = reversedDiff.isEmpty ? 0 : reversedDiff[0]["version"];
       String defaultAuthor = "_clean_";

       reversedDiff.forEach((Map change) {
         if (change["action"] == "add") {
           clientData.removeWhere((d) =&gt; d["_id"] == change["_id"]);
         }
         else if (change["action"] == "remove") {
           _insertIntoSorted(clientData, change["data"], _sortParams);
         }
         else if (change["action"] == "change") {
           Map record = clientData.firstWhere((d) =&gt; d["_id"] == change["_id"]);

           if (record == null) {
             //TODO: the record should be certainly in clientData, throw some nice exception here
           }

           record.addAll(slice(change["before"], change["data"].keys.toList()));
           clientData.sort(_getComparator(_sortParams));

           if (!record.containsKey("_metadata")) {
             record["_metadata"] = {};
           }

           change["data"].forEach((name, value) {
             if (!record["_metadata"].containsKey(name)) {
               record["_metadata"][name] = value;
             }
           });

         }
       });

       if (clientData.length &gt; _skip) {
         clientData = clientData.getRange(_skip, [clientData.length, _skip + _limit].reduce(min)).toList();
       }
       else {
         clientData = [];
       }

       Set clientDataSet = new Set.from(clientData.map((d) =&gt; d['_id']));
       Set dataSet = new Set.from(currentData.map((d) =&gt; d['_id']));

       // as these diffs are generated from two data views (not fetched from
       // the DB), there is no way to tell the version nor author. These diffs
       // have to be applied alltogether or not at all

       clientData.forEach((Map clientRecord) {
         if (dataSet.contains(clientRecord["_id"])) {
           if (clientRecord.containsKey("_metadata")) {
             clientDiff.add({
               "action" : "change",
               "_id" : clientRecord["_id"],
               "data" : clientRecord["_metadata"],
               "version" : maxVersion,
               "author" : defaultAuthor,
             });
           }
         }
         else {
           // data does not contain the clientRecord thus it needs to be removed
           clientDiff.add({
             "action" : "remove",
             "_id" : clientRecord["_id"],
             "version" : maxVersion,
             "author" : defaultAuthor,
           });
         }
       });

       currentData.forEach((Map record) {
         if (!clientDataSet.contains(record["_id"])) {
           clientDiff.add({
             "action" : "add",
             "_id" : record["_id"],
             "data" : record,
             "version" : maxVersion,
             "author" : defaultAuthor,
           });
         }
       });

       return clientDiff;
     });
   });
 }

 Future _get_locks() {
   return _lock.insert({'_id': collection.collectionName}).then(
     (_) =&gt; _lock.insert({'_id': _collectionHistory.collectionName}),
     onError: (e) {
       if(e['code'] == 11000) {
         // duplicate key error index
         return _get_locks();
       } else {
         throw(e);
       }
     }).then((_) =&gt; true);
 }

 Future _release_locks() {
   return _lock.remove({'_id': _collectionHistory.collectionName}).then((_) =&gt;
   _lock.remove({'_id': collection.collectionName})).then((_) =&gt;
   true);
 }

 void _stripCleanVersion(dynamic data) {
   if (data is Iterable) {
     data.forEach((Map item) {
       item.remove('__clean_version');
     });
   } else {
     data.remove('__clean_version');
   }
 }
}
</pre>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../clean_sync.server/DataProvider.html">DataProvider</a></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>MongoProvider</strong>(<a href="../mongo_dart/DbCollection.html">DbCollection</a> collection, <a href="../mongo_dart/DbCollection.html">DbCollection</a> _collectionHistory, <a href="../mongo_dart/DbCollection.html">DbCollection</a> _lock) <a class="anchor-link" href="#"
              title="Permalink to MongoProvider.MongoProvider">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="http://api.dartlang.org/dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> </div></div>
<pre class="source">
MongoProvider(this.collection, this._collectionHistory, this._lock);
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="collection">
<button class="show-code">Code</button>
final <a href="../mongo_dart/DbCollection.html">DbCollection</a>         <strong>collection</strong> <a class="anchor-link"
            href="#collection"
            title="Permalink to MongoProvider.collection">#</a>
        </h4>
        <div class="doc">
<pre class="source">
final DbCollection collection
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="add">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>add</strong>(<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> data, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> author) <a class="anchor-link" href="#add"
              title="Permalink to MongoProvider.add">#</a></h4>
<div class="doc">
<pre class="source">
Future add(Map data, String author) {
 num nextVersion;
 return _get_locks().then((_) =&gt; _maxVersion).then((version) {
     nextVersion = version + 1;
     data[VERSION_FIELD_NAME] = nextVersion;
     return collection.insert(data);
   }).then((_) =&gt;
     _collectionHistory.insert({
       "before" : {},
       "after" : data,
       "action" : "add",
       "author" : author,
       "version" : nextVersion
     }),
   onError: (e) {
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     return _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
}
</pre>
</div>
</div>
<div class="method"><h4 id="addAll">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>addAll</strong>(<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a>&gt; data, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> author) <a class="anchor-link" href="#addAll"
              title="Permalink to MongoProvider.addAll">#</a></h4>
<div class="doc">
<pre class="source">
Future addAll(List&lt;Map&gt; data, String author) {
 num nextVersion;
 return _get_locks().then((_) =&gt; _maxVersion).then((version) {
     nextVersion = version + 1;
     data.forEach((elem) =&gt; elem[VERSION_FIELD_NAME] = nextVersion++);
     return collection.insertAll(data);
   }).then((_) =&gt;
     _collectionHistory.insertAll(data.map((elem) =&gt;
         {
           "before" : {},
           "after" : elem,
           "action" : "add",
           "author" : author,
           "version" : elem[VERSION_FIELD_NAME]
         }).toList(growable: false)),
   onError: (e) {
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     return _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
}
</pre>
</div>
</div>
<div class="method"><h4 id="change">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>change</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> _id, <a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> change, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> author) <a class="anchor-link" href="#change"
              title="Permalink to MongoProvider.change">#</a></h4>
<div class="doc">
<pre class="source">
Future change(String _id, Map change, String author) {
 num nextVersion;
 Map newRecord;
 return _get_locks().then((_) =&gt; collection.findOne({"_id" : _id}))
   .then((Map record) {
     if(record == null) {
       return true;
//          throw new MongoException(null,
//              'Change was not applied, document with id $_id does not exist.');
     } else if (change.containsKey('_id') &amp;&amp; change['_id'] != _id) {
       throw new MongoException(null,
           'New document id ${change['_id']} should be same as old one $_id.');
     } else {
       return _maxVersion.then((version) {
         nextVersion = version + 1;
         newRecord = change;
         newRecord[VERSION_FIELD_NAME] = nextVersion;
         return collection.save(newRecord);
       }).then((_) =&gt;
         _collectionHistory.insert({
           "before" : record,
           "after" : newRecord,
           "action" : "change",
           "author" : author,
           "version" : nextVersion
         }));
     }
   },
   onError: (e) {
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     return _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
}
</pre>
</div>
</div>
<div class="method"><h4 id="data">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a>&gt; <strong>data</strong>({projection: null, stripVersion: true}) <a class="anchor-link" href="#data"
              title="Permalink to MongoProvider.data">#</a></h4>
<div class="doc">
<p>Returns data and version of this data 7.</p>
<pre class="source">
Future&lt;Map&gt; data({projection: null, stripVersion: true}) {
 return collection.find(where.raw(_rawSelector).limit(_limit).skip(_skip)).toList().then((data) {
   //return _maxVersion.then((version) =&gt; {'data': data, 'version': version});
   var version = data.length == 0 ? 0 : data.map((item) =&gt; item['__clean_version']).reduce(max);
   if(stripVersion) _stripCleanVersion(data);
   if (projection != null){
     data.forEach((e) =&gt; projection(e));
   }
   return {'data': data, 'version': version};
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="deleteHistory">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>deleteHistory</strong>(<a href="http://api.dartlang.org/dart_core/num.html" ref="external">num</a> version) <a class="anchor-link" href="#deleteHistory"
              title="Permalink to MongoProvider.deleteHistory">#</a></h4>
<div class="doc">
<pre class="source">
Future deleteHistory(num version) {
 return _collectionHistory.remove({'version': {LT: version}});
}
</pre>
</div>
</div>
<div class="method"><h4 id="deprecatedChange">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>deprecatedChange</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> _id, <a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> change, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> author) <a class="anchor-link" href="#deprecatedChange"
              title="Permalink to MongoProvider.deprecatedChange">#</a></h4>
<div class="doc">
<pre class="source">
Future deprecatedChange(String _id, Map change, String author) {
 num nextVersion;
 Map newRecord;
 return _get_locks().then((_) =&gt; collection.findOne({"_id" : _id}))
   .then((Map record) {
     if(record == null) {
       throw new MongoException(null,
           'Change was not applied, document with id $_id does not exist.');
     } else if (change.containsKey('_id') &amp;&amp; change['_id'] != _id) {
       throw new MongoException(null,
           'New document id ${change['_id']} should be same as old one $_id.');
     } else {
       return _maxVersion.then((version) {
         nextVersion = version + 1;
         newRecord = new Map.from(record);
         newRecord.addAll(change);
         newRecord[VERSION_FIELD_NAME] = nextVersion;
         return collection.save(newRecord);
       }).then((_) =&gt;
         _collectionHistory.insert({
           "before" : record,
           "after" : newRecord,
           "action" : "change",
           "author" : author,
           "version" : nextVersion
         }));
     }
   },
   onError: (e) {
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     return _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
}
</pre>
</div>
</div>
<div class="method"><h4 id="diffFromVersion">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a>&gt; <strong>diffFromVersion</strong>(<a href="http://api.dartlang.org/dart_core/num.html" ref="external">num</a> version, {projection: null}) <a class="anchor-link" href="#diffFromVersion"
              title="Permalink to MongoProvider.diffFromVersion">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns collection of items in the following form:
 {'diff': [List<Map>]} or
 {'diff': null, 'data': [List<Map>] data, 'version': <a class="crossref" href="http://api.dartlang.org/dart_core/num.html">num</a> version_num}</p>
<p> If 'diff' value is not null, items in the list are of following form:
 {'action': 'add'/'change',
  '<em>id': 'value0',
  'author': 'Some String',
  'data': {'</em>id': 'value0', 'field1': 'value1', 'field2': 'value2', ...}
  'version': 5}</p>
<p> or</p>
<p> {'action': 'remove',
  '_id': 'value0',
  'author': 'Some String',
  'version': 5}</p>
<p> In case of 'add', value of 'data' is a <a class="crossref" href="http://api.dartlang.org/dart_core/Map.html">Map</a> representing new data that
 was added. In case of 'change', value of 'data' is a <a class="crossref" href="http://api.dartlang.org/dart_core/Map.html">Map</a> containing new
 key-value pairs and/or pairs of already existing keys and updated values.</p>
<div class="docs-inherited-from">docs inherited from <a href="../clean_sync.server/DataProvider.html">DataProvider</a> </div></div>
<pre class="source">
Future&lt;Map&gt; diffFromVersion(num version, {projection: null}) {
 try{
   return _diffFromVersion(version, projection: projection).then((d) {
     return d;
   });
 } on DiffNotPossibleException catch(e) {
   return data(projection: projection).then((d) {
     d['diff'] = null;
     return d;
   });
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="find">
<button class="show-code">Code</button>
<a href="../clean_sync.server/MongoProvider.html">MongoProvider</a> <strong>find</strong>(<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> params) <a class="anchor-link" href="#find"
              title="Permalink to MongoProvider.find">#</a></h4>
<div class="doc">
<pre class="source">
MongoProvider find(Map params) {
 var mp = new MongoProvider(collection, _collectionHistory, _lock);
 mp._copySelection(this);
 mp._selectorList.add(params);
 return mp;
}
</pre>
</div>
</div>
<div class="method"><h4 id="limit">
<button class="show-code">Code</button>
<a href="../clean_sync.server/MongoProvider.html">MongoProvider</a> <strong>limit</strong>(<a href="http://api.dartlang.org/dart_core/num.html" ref="external">num</a> value) <a class="anchor-link" href="#limit"
              title="Permalink to MongoProvider.limit">#</a></h4>
<div class="doc">
<pre class="source">
MongoProvider limit(num value) {
 var mp = new MongoProvider(collection, _collectionHistory, _lock);
 mp._copySelection(this);
 mp._limit = value;
 return mp;
}
</pre>
</div>
</div>
<div class="method"><h4 id="pretify">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a> <strong>pretify</strong>(<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a> diff) <a class="anchor-link" href="#pretify"
              title="Permalink to MongoProvider.pretify">#</a></h4>
<div class="doc">
<pre class="source">
List pretify(List diff){
 Set seen = new Set();
 var res = [];
 for (Map change in diff.reversed) {
   var id = change['_id']+change['action'];
   assert(id is String);
   if (!seen.contains(id)) {
     res.add(change);
   }
   seen.add(id);
 }
 return new List.from(res.reversed);
}
</pre>
</div>
</div>
<div class="method"><h4 id="remove">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>remove</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> _id, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> author) <a class="anchor-link" href="#remove"
              title="Permalink to MongoProvider.remove">#</a></h4>
<div class="doc">
<pre class="source">
Future remove(String _id, String author) {
 num nextVersion;
 return _get_locks().then((_) =&gt; _maxVersion).then((version) {
     nextVersion = version + 1;
     return collection.findOne({'_id': _id});
   }).then((record) {
     if (record == null) {
       return true;
     } else {
       return collection.remove({'_id': _id}).then((_) =&gt;
         _collectionHistory.insert({
           "before" : record,
           "after" : {},
           "action" : "remove",
           "author" : author,
           "version" : nextVersion
       }));
     }
   },
   onError: (e) {
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     return _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
}
</pre>
</div>
</div>
<div class="method"><h4 id="removeAll">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>removeAll</strong>(query, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> author) <a class="anchor-link" href="#removeAll"
              title="Permalink to MongoProvider.removeAll">#</a></h4>
<div class="doc">
<pre class="source">
Future removeAll(query, String author) {
 num nextVersion;
 return _get_locks().then((_) =&gt; _maxVersion).then((version) {
     nextVersion = version + 1;
     return collection.find(query).toList();
   }).then((data) {
     return collection.remove(query).then((_) =&gt;
       _collectionHistory.insertAll(data.map((elem) =&gt; {
         "before" : elem,
         "after" : {},
         "action" : "remove",
         "author" : author,
         "version" : nextVersion++
     }).toList(growable: false)));
   },
   onError: (e) {
     // Errors thrown by MongoDatabase are Map objects with fields err, code,
     // ...
     return _release_locks().then((_) {
       throw new MongoException(e);
     });
   }
   ).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion);
}
</pre>
</div>
</div>
<div class="method"><h4 id="skip">
<button class="show-code">Code</button>
<a href="../clean_sync.server/MongoProvider.html">MongoProvider</a> <strong>skip</strong>(<a href="http://api.dartlang.org/dart_core/num.html" ref="external">num</a> value) <a class="anchor-link" href="#skip"
              title="Permalink to MongoProvider.skip">#</a></h4>
<div class="doc">
<pre class="source">
MongoProvider skip(num value) {
 var mp = new MongoProvider(collection, _collectionHistory, _lock);
 mp._copySelection(this);
 mp._skip = value;
 return mp;
}
</pre>
</div>
</div>
<div class="method"><h4 id="sort">
<button class="show-code">Code</button>
<a href="../clean_sync.server/MongoProvider.html">MongoProvider</a> <strong>sort</strong>(<a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> params) <a class="anchor-link" href="#sort"
              title="Permalink to MongoProvider.sort">#</a></h4>
<div class="doc">
<pre class="source">
MongoProvider sort(Map params) {
 var mp = new MongoProvider(collection, _collectionHistory, _lock);
 mp._copySelection(this);
 mp._sortParams.addAll(params);
 return mp;
}
</pre>
</div>
</div>
<div class="method"><h4 id="update">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>update</strong>(selector, <a href="http://api.dartlang.org/dart_core/Map.html" ref="external">Map</a> document, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> author, {<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> upsert: false, <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> multiUpdate: false, <a href="../mongo_dart/WriteConcern.html">WriteConcern</a> writeConcern}) <a class="anchor-link" href="#update"
              title="Permalink to MongoProvider.update">#</a></h4>
<div class="doc">
<pre class="source">
Future update(selector,Map document, String author, {bool upsert: false, bool multiUpdate: false, WriteConcern writeConcern}) {
 num nextVersion;
 List oldData;
 return _get_locks().then((_) =&gt; _maxVersion).then((version) {
     nextVersion = version + 1;
     num versionUpdate = nextVersion;
     var prepare;
     if(document.keys.any((K) =&gt; K.startsWith('\$'))) {
       prepare = (doc) {
         doc[SET][VERSION_FIELD_NAME] =  versionUpdate++;
         return doc;
       };
       if(!document.containsKey(SET))
         document[SET] = {};
     }
     else {
       prepare = (doc) {
         doc[VERSION_FIELD_NAME] =  versionUpdate++;
         return doc;
       };
     }

     var col = collection.find(selector);
     return col.toList().then((data) {
       oldData = data;
       return Future.forEach(data,
           (item) =&gt; collection.update({'_id': item['_id']},
               prepare(document), upsert: upsert, multiUpdate: multiUpdate,
               writeConcern: writeConcern));
     });
   }).then((_) {
     return Future.forEach(oldData,
       (oldItem) {
         return collection.find({'_id': oldItem['_id']}).toList().then((newItem) =&gt;
         _collectionHistory.insert({
           "before" : oldItem,
           "after" : newItem.single,
           "action" : "change",
           "author" : author,
           "version" : nextVersion++
         }));
       });
     }).then((_) =&gt; _release_locks()).then((_) =&gt; nextVersion)
     .catchError( (e) {
       // Errors thrown by MongoDatabase are Map objects with fields err, code,
       // ...
       return _release_locks().then((_) {
         throw new MongoException(e);
       });
     });
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
